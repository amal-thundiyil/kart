import logging
import os
import subprocess
import sys
import platform
import shlex
import click
from pathlib import Path

from docutils.core import publish_string
from docutils.writers import manpage
from kart.docs import COMMANDS_FOLDER, ManPage, BaseDocWriter

L = logging.getLogger("kart.help")


class ExecutableNotFoundError(Exception):
    def __init__(self, executable_name):
        super(ExecutableNotFoundError, self).__init__()


def kart_help(ctx: click.Context):
    doc = Path(COMMANDS_FOLDER) / f"{ctx.command_path}.rst"
    contents = ""
    if doc.exists():
        contents = doc.read_text()
    help_render = get_renderer()
    help_render.render(ctx, contents)


def get_renderer():
    """
    Return the appropriate HelpRenderer implementation for the
    current platform.
    """
    if platform.system() == "Windows":
        return WindowsHelpRenderer()

    return PosixHelpRenderer()


class PagingHelpRenderer:
    """
    Interface for a help renderer.

    The renderer is responsible for displaying the help content on
    a particular platform.
    """

    def __init__(self, output_stream=sys.stdout):
        self.output_stream = output_stream

    PAGER = None

    def get_pager_cmdline(self):
        """Gets the suitable pager from the system environment or uses the default PAGER

        Returns:
            str: pager obtained from the system or default PAGER
        """
        pager = self.PAGER
        if "MANPAGER" in os.environ:
            pager = os.environ["MANPAGER"]
        elif "PAGER" in os.environ:
            pager = os.environ["PAGER"]
        return shlex.split(pager)

    def render(self, ctx: click.Context, contents: str):
        """Converts the reST doc content to man and sends it to a suitable pager

        Args:
            ctx (click.Context): _description_
            contents (_type_): _description_
        """
        converted_content = self._convert_doc_content(ctx, contents)
        self._send_output_to_pager(converted_content)

    def _send_output_to_pager(self, output: str):
        """Send the output generated by the renderers to a suitable pager

        Args:
            output (str): "man" string output post conversion from rst
        """
        cmdline = self.get_pager_cmdline()
        L.debug("Running command: %s", cmdline)
        p = self._popen(cmdline, stdin=subprocess.PIPE)
        p.communicate(input=output)

    def _popen(self, *args, **kwargs):
        return subprocess.Popen(*args, **kwargs)

    def _convert_doc_content(self, ctx, contents):
        return contents


class PosixHelpRenderer(PagingHelpRenderer):
    """
    Render help content on a Posix-like system.  This includes
    Linux and MacOS X.
    """

    PAGER = "less -R"

    def _convert_doc_content(self, ctx, contents):
        man_page = self._convert_doc_content_body(ctx, contents)
        if not self._exists_on_path("groff"):
            raise ExecutableNotFoundError("groff")
        cmdline = ["groff", "-m", "man", "-T", "ascii"]
        L.debug("Running command: %s", cmdline)
        p3 = self._popen(
            cmdline,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        groff_output = p3.communicate(input=man_page)[0]
        return groff_output

    def _convert_doc_content_body(self, ctx, contents):
        # we add a header to the man page and remove it later
        # to avoid parsing the rst2man "metadata" in ManPage
        header = "KART\n====\n"
        man_contents = publish_string(
            header + contents, writer=manpage.Writer()
        ).decode("utf-8")[718:]
        doc = ManPage(ctx, man_contents)
        writer = BaseDocWriter.get_doc_writer(doc)
        man_page = writer.write()
        return bytes(man_page, "utf-8")

    def _send_output_to_pager(self, output):
        cmdline = self.get_pager_cmdline()
        if not self._exists_on_path(cmdline[0]):
            L.debug("Pager '%s' not found in PATH, printing raw help." % cmdline[0])
            self.output_stream.write(output.decode("utf-8") + "\n")
            self.output_stream.flush()
            return
        L.debug("Running command: %s", cmdline)
        p = self._popen(cmdline, stdin=subprocess.PIPE)
        p.communicate(input=output)

    def _exists_on_path(self, name):
        return any(
            [
                os.path.exists(os.path.join(p, name))
                for p in os.environ.get("PATH", "").split(os.pathsep)
            ]
        )
